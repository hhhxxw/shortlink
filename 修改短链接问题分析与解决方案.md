# 修改短链接问题分析与解决方案

## 🔴 问题诊断

### 核心问题
修改短链接功能在**分库分表（ShardingSphere）场景下查询不到数据**。

### 问题原因

1. **分片键配置**：`gid`（分组标识）是ShardingSphere的分片键
   ```yaml
   # shardingsphere-config-dev.yaml
   shardingColumn: gid  # 使用 gid 作为分片键
   type: HASH_MOD       # 哈希取模算法
   sharding-count: 16   # 16个分片表
   ```

2. **错误的查询逻辑**（修复前）：
   ```java
   // ❌ 错误：使用新的gid查询旧的记录
   LambdaQueryWrapper<ShortLinkDO> queryWrapper = Wrappers.lambdaQuery(ShortLinkDO.class)
       .eq(ShortLinkDO::getGid, requestParam.getGid())  // 这是新的gid！
       .eq(ShortLinkDO::getFullShortUrl, requestParam.getFullShortUrl())
       .eq(ShortLinkDO::getDelFlag, 0);
   ```

3. **数据路由问题**：
   - 假设短链接原本在分组A（originalGid = "A"）
   - 用户想移动到分组B（newGid = "B"）
   - ShardingSphere根据gid计算分片：
     - 分组A → 路由到分片表 t_link_5
     - 分组B → 路由到分片表 t_link_12
   - 使用新gid查询时，ShardingSphere会路由到 t_link_12
   - 但数据实际还在 t_link_5 中 → **查询失败！**

## ✅ 解决方案

### 核心思路
区分**原始gid**（用于定位记录）和**目标gid**（用于更新数据）。

### 修改内容

#### 1. DTO字段增强

**admin端** (`ShortLinkUpdateReqDTO.java`)：
```java
/**
 * 原始分组标识（用于定位记录）
 */
private String originalGid;

/**
 * 分组标识（目标分组）
 */
private String gid;
```

**project端** (`ShortLinkUpdateReqDTO.java`)：
```java
// 相同的字段定义
private String originalGid;  // 原始分组
private String gid;          // 目标分组
```

#### 2. Service层查询逻辑修正

**关键修改点**：
```java
// ✅ 正确：使用原始gid查询
LambdaQueryWrapper<ShortLinkDO> queryWrapper = Wrappers.lambdaQuery(ShortLinkDO.class)
    .eq(ShortLinkDO::getGid, requestParam.getOriginalGid())  // 使用原始gid
    .eq(ShortLinkDO::getFullShortUrl, requestParam.getFullShortUrl())
    .eq(ShortLinkDO::getDelFlag, 0);
```

**完整的更新逻辑**：
```java
@Override
@Transactional(rollbackFor = Exception.class)
public void updateShortLink(ShortLinkUpdateReqDTO requestParam) {
    // 1. 参数校验
    if (requestParam.getOriginalGid() == null || requestParam.getOriginalGid().trim().isEmpty()) {
        throw new ServiceException("原始分组标识不能为空");
    }
    
    // 2. 使用originalGid查询记录（确保路由到正确的分片表）
    LambdaQueryWrapper<ShortLinkDO> queryWrapper = Wrappers.lambdaQuery(ShortLinkDO.class)
        .eq(ShortLinkDO::getGid, requestParam.getOriginalGid())
        .eq(ShortLinkDO::getFullShortUrl, requestParam.getFullShortUrl())
        .eq(ShortLinkDO::getDelFlag, 0);
    ShortLinkDO hasShortLinkDO = baseMapper.selectOne(queryWrapper);
    
    // 3. 判断gid是否变化
    if (Objects.equals(requestParam.getOriginalGid(), requestParam.getGid())) {
        // 情况1：gid未变化，直接更新
        LambdaUpdateWrapper<ShortLinkDO> updateWrapper = Wrappers.lambdaUpdate(ShortLinkDO.class)
            .eq(ShortLinkDO::getId, requestParam.getId())
            .eq(ShortLinkDO::getGid, requestParam.getOriginalGid())
            .eq(ShortLinkDO::getDelFlag, 0);
        baseMapper.update(shortLinkDO, updateWrapper);
    } else {
        // 情况2：gid已变化，删除旧记录 + 插入新记录（跨分片迁移）
        LambdaUpdateWrapper<ShortLinkDO> deleteWrapper = Wrappers.lambdaUpdate(ShortLinkDO.class)
            .eq(ShortLinkDO::getId, requestParam.getId())
            .eq(ShortLinkDO::getGid, requestParam.getOriginalGid())  // 使用原始gid删除
            .eq(ShortLinkDO::getDelFlag, 0);
        baseMapper.delete(deleteWrapper);
        
        baseMapper.insert(shortLinkDO);  // 新记录会根据新gid路由到新分片表
    }
}
```

## 📋 前端改动要点

### API调用参数调整

**修改前**：
```javascript
// ❌ 只传递新的gid
{
  id: 123,
  gid: "new-group-id",        // 新分组
  originUrl: "https://...",
  describe: "..."
}
```

**修改后**：
```javascript
// ✅ 同时传递原始gid和新gid
{
  id: 123,
  originalGid: "old-group-id",  // 原始分组（关键！）
  gid: "new-group-id",          // 目标分组
  originUrl: "https://...",
  describe: "..."
}
```

### 前端实现建议

```javascript
// 在编辑对话框打开时，保存原始gid
const [originalGid, setOriginalGid] = useState('');

function openEditDialog(shortLink) {
  setOriginalGid(shortLink.gid);  // 保存原始gid
  // ... 其他逻辑
}

// 提交时同时传递originalGid和gid
function handleSubmit(formData) {
  const payload = {
    id: formData.id,
    originalGid: originalGid,     // 原始分组
    gid: formData.gid,            // 用户选择的新分组
    originUrl: formData.originUrl,
    describe: formData.describe,
    // ... 其他字段
  };
  
  api.updateShortLink(payload);
}
```

## 🧪 测试验证

### 测试场景

#### 场景1：gid不变（同组内修改）
```
原始：gid = "group-1", originUrl = "https://old.com"
修改：gid = "group-1", originUrl = "https://new.com"

预期：直接在 t_link_X 表中更新记录
```

#### 场景2：gid改变（跨组移动）
```
原始：gid = "group-1", originUrl = "https://example.com"
修改：gid = "group-2", originUrl = "https://example.com"

预期：
1. 从 t_link_5 删除记录（假设group-1路由到分片5）
2. 向 t_link_12 插入记录（假设group-2路由到分片12）
```

### 测试步骤

1. **创建测试数据**：
   ```sql
   -- 创建一个短链接
   INSERT INTO t_link (gid, full_short_url, origin_url, ...) 
   VALUES ('test-group-1', 'http://short.com/abc', 'https://example.com', ...);
   ```

2. **测试同组修改**：
   ```bash
   PUT /api/short-link/admin/v1/update
   {
     "id": 1,
     "originalGid": "test-group-1",
     "gid": "test-group-1",
     "originUrl": "https://new-example.com"
   }
   ```

3. **测试跨组移动**：
   ```bash
   PUT /api/short-link/admin/v1/update
   {
     "id": 1,
     "originalGid": "test-group-1",
     "gid": "test-group-2",
     "originUrl": "https://new-example.com"
   }
   ```

4. **验证数据库**：
   ```sql
   -- 查看原分片表（应该已删除或标记删除）
   SELECT * FROM t_link_X WHERE full_short_url = 'http://short.com/abc';
   
   -- 查看新分片表（应该有新记录）
   SELECT * FROM t_link_Y WHERE full_short_url = 'http://short.com/abc';
   ```

## 📚 知识扩展

### ShardingSphere分片路由原理

```
查询SQL: SELECT * FROM t_link WHERE gid = 'group-1' AND ...

ShardingSphere路由过程：
1. 识别分片键：gid = 'group-1'
2. 计算哈希值：hash('group-1') = 12345
3. 取模运算：12345 % 16 = 5
4. 路由到分片：t_link_5
5. 执行真实SQL：SELECT * FROM t_link_5 WHERE gid = 'group-1' AND ...
```

### 为什么必须用originalGid？

| 场景 | 使用字段 | ShardingSphere路由 | 结果 |
|------|---------|-------------------|------|
| 查询旧记录 | newGid | 路由到新分片表 | ❌ 查不到（数据在旧分片） |
| 查询旧记录 | originalGid | 路由到旧分片表 | ✅ 查到数据 |
| 更新到新分组 | newGid | 插入新分片表 | ✅ 正确 |

### 跨分片更新的策略

**方案对比**：

| 方案 | 优点 | 缺点 | 适用场景 |
|------|------|------|----------|
| 直接UPDATE | 简单 | ❌ 无法跨分片 | gid不变 |
| DELETE + INSERT | ✅ 支持跨分片 | 事务复杂 | gid改变 |
| 软删除 + INSERT | 保留历史 | 数据冗余 | 需要审计 |

本项目采用 **DELETE + INSERT** 方案，在事务中保证原子性。

## ⚠️ 注意事项

1. **前端必须传递originalGid**：这是定位记录的关键！
2. **originalGid不能为空**：已添加参数校验
3. **事务保证**：跨分片的删除+插入操作在同一事务中，确保数据一致性
4. **全链路日志**：建议在调试阶段打开SQL日志查看实际执行的分片路由

## 📝 总结

这是一个典型的**分库分表场景下的跨分片更新问题**。核心要点：

1. ✅ 使用 `originalGid` 定位旧记录（确保路由到正确的分片表）
2. ✅ 使用 `gid` 指定目标分组（决定新记录的分片位置）
3. ✅ 跨分片更新采用"删除旧记录 + 插入新记录"策略
4. ✅ 前端需要同时传递 `originalGid` 和 `gid`

---

**修改完成后，请重新编译项目并测试功能！**




