# 401 Unauthorized 错误修复指南

## 🔴 问题诊断

### 错误信息
```
org.springframework.web.client.HttpClientErrorException$Unauthorized: 401 : [no body]
```

### 根本原因

**admin服务调用project服务时，缺少用户认证信息传递**

1. **admin服务**: 有UserTransmitFilter，从HTTP Header中获取username和token
2. **project服务**: 启用了Spring Security，但没有接收用户信息的机制
3. **远程调用**: admin → project时，RestTemplate没有传递username
4. **结果**: project服务的Spring Security拦截请求，返回401错误

## ✅ 修复方案

### 已完成的代码修改

#### 修改1：admin服务 - 传递用户信息

**文件**: `admin/src/main/java/com/nageoffer/shorlink/admin/remote/ShortLinkRemoteServiceImpl.java`

```java
// 添加导入
import com.nageoffer.shorlink.admin.common.biz.user.UserContext;

// 在updateShortLink方法中添加
HttpHeaders headers = new HttpHeaders();
headers.setContentType(MediaType.APPLICATION_JSON);

// 传递用户信息到project服务（关键修复！）
String username = UserContext.getUsername();
if (username != null) {
    headers.set("username", username);
    log.info("传递用户信息 - username: {}", username);
}
```

#### 修改2：project服务 - 接收用户信息

**新增文件**:
1. `project/src/main/java/com/nageoffer/shorlink/project/common/biz/user/UserContext.java`
2. `project/src/main/java/com/nageoffer/shorlink/project/common/biz/user/UserTransmitFilter.java`
3. `project/src/main/java/com/nageoffer/shorlink/project/config/UserConfiguration.java`

**功能**: 从HTTP Header中提取username，存入ThreadLocal

#### 修改3：project服务 - 关闭Spring Security认证

**新增文件**: `project/src/main/java/com/nageoffer/shorlink/project/config/SecurityConfiguration.java`

```java
@Configuration
@EnableWebSecurity
public class SecurityConfiguration {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf(AbstractHttpConfigurer::disable)
            .authorizeHttpRequests(auth -> auth
                .anyRequest().permitAll()  // 允许所有请求
            );
        return http.build();
    }
}
```

#### 修改4：project服务 - 添加依赖

**文件**: `project/pom.xml`

```xml
<!-- 线程本地变量传递 -->
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>transmittable-thread-local</artifactId>
    <version>2.14.2</version>
</dependency>
```

---

## 🚀 重启服务

### ⚠️ 重要：必须重新编译并重启服务！

### 步骤1：停止现有服务

在IDEA中停止：
- ❌ 停止 project 服务
- ❌ 停止 admin 服务

或在终端中：
```bash
# 查找Java进程
jps

# 停止进程（替换为实际PID）
taskkill /F /PID <project_pid>
taskkill /F /PID <admin_pid>
```

### 步骤2：重新编译

```bash
# 方式1：在项目根目录
mvn clean compile

# 方式2：分别编译
cd project
mvn clean compile

cd ../admin
mvn clean compile
```

### 步骤3：重启服务

**必须按顺序启动**：

#### ① 先启动 project 服务
```bash
# 方式1：使用Maven
cd project
mvn spring-boot:run

# 方式2：使用IDEA
# 运行 ShortLinkApplication.java
```

**确认启动成功**：
```
看到日志：
Started ShortLinkApplication in X.XXX seconds
```

访问：http://127.0.0.1:8001 （应该可以访问）

#### ② 再启动 admin 服务
```bash
# 方式1：使用Maven
cd admin
mvn spring-boot:run

# 方式2：使用IDEA
# 运行 ShortLinkAdminApplication.java
```

**确认启动成功**：
```
看到日志：
Started ShortLinkAdminApplication in X.XXX seconds
```

访问：http://127.0.0.1:8902 （应该可以访问）

---

## 🧪 验证修复

### 测试步骤

#### 1. 在Apifox中重新测试

**请求配置**：
- 方法：`PUT`
- URL：`http://127.0.0.1:8902/api/short-link/admin/v1/update`
- Headers：
  ```
  Content-Type: application/json
  username: your_username     ← 确保传递用户名
  token: your_token           ← 确保传递token
  ```

**Body**：
```json
{
  "id": 1971909001333448705,
  "originalGid": "m6zLqv",
  "gid": "nw6zLq",
  "fullShortUrl": "http://baidu.com/1evvi1",
  "originUrl": "http://qrrix.ba/qqqzr12",
  "describe": "测试跨组移动",
  "validDateType": 0
}
```

**预期成功响应**：
```json
{
  "code": "0",
  "message": "success",
  "data": null,
  "success": true
}
```

#### 2. 查看后台日志

**admin服务日志** (应该看到):
```
远程调用修改短链接开始 - URL: http://127.0.0.1:8001/api/short-link/v1/update
传递用户信息 - username: xxxx
远程调用修改短链接成功
```

**project服务日志** (应该看到):
```
接收到用户信息 - username: xxxx
修改短链接开始，id: 1971909001333448705
查询短链接，originalGid: m6zLqv, fullShortUrl: http://baidu.com/1evvi1
查询到短链接，id: 1971909001333448705, originalGid: m6zLqv, targetGid: nw6zLq
gid 已变化，执行删除+插入操作，旧gid: m6zLqv, 新gid：nw6zLq
修改短链接成功，id: 1971909001333448705
```

#### 3. 验证数据迁移

**在新分组查询**：
```http
GET http://127.0.0.1:8902/api/short-link/admin/v1/page?gid=nw6zLq&current=1&size=10
```
✅ 应该能查到记录

**在旧分组查询**：
```http
GET http://127.0.0.1:8902/api/short-link/admin/v1/page?gid=m6zLqv&current=1&size=10
```
✅ 应该查不到该记录

---

## 📋 问题排查清单

### 如果还是401错误

#### 检查1：确认服务已重启
```bash
# 查看Java进程启动时间
jps -lv

# 应该是最近几分钟内启动的
```

#### 检查2：确认SecurityConfiguration生效
在project服务启动日志中查找：
```
Using generated security password: ...
```
如果看到这个日志，说明SecurityConfiguration没有生效，需要检查：
- 文件位置是否正确：`project/src/main/java/com/nageoffer/shorlink/project/config/SecurityConfiguration.java`
- @Configuration 和 @EnableWebSecurity 注解是否正确

#### 检查3：确认UserTransmitFilter生效
在project服务启动日志中查找：
```
Mapping filter: 'globalUserTransmitFilter' to: [/*]
```
如果没有看到，说明UserConfiguration没有生效

#### 检查4：确认username传递
在Apifox的Headers中必须包含：
```
username: your_username
token: your_token
```

可以在admin服务日志中确认：
```
传递用户信息 - username: xxxx
```

### 如果是其他错误

#### "短链接记录不存在"
- 检查originalGid是否正确
- 检查fullShortUrl是否正确
- 参考之前的《测试失败原因分析.md》

#### "系统执行出错"
- 查看project服务的详细日志
- 检查数据库连接是否正常
- 检查ShardingSphere配置

---

## 🎯 完整测试流程

### 准备工作
1. ✅ 停止所有服务
2. ✅ 重新编译代码
3. ✅ 启动project服务 (8001)
4. ✅ 启动admin服务 (8902)
5. ✅ 确认两个服务都启动成功

### 测试修改接口
1. ✅ 在Apifox配置Headers（username + token）
2. ✅ 填写正确的请求参数（originalGid + gid）
3. ✅ 发送请求
4. ✅ 收到成功响应 (code = "0")
5. ✅ 查看后台日志确认执行流程
6. ✅ 查询验证数据已迁移

---

## 📝 技术总结

### 问题根源
1. **Spring Security默认启用**: project服务引入了spring-boot-starter-security依赖
2. **缺少用户信息传递**: admin调用project时没有传递认证信息
3. **缺少接收机制**: project没有接收和处理用户信息的Filter

### 解决方案
1. **传递用户信息**: admin在RestTemplate调用时添加username到Header
2. **接收用户信息**: project添加UserTransmitFilter提取username
3. **关闭Security认证**: 配置Spring Security允许所有请求
4. **添加必要依赖**: transmittable-thread-local用于线程本地变量传递

### 架构说明
```
前端/Apifox
  ↓ (带 username + token)
Admin服务 (8902)
  ├─ UserTransmitFilter: 验证并存储username
  ├─ Controller: 接收请求
  └─ ShortLinkRemoteServiceImpl: 
      ├─ 从UserContext获取username
      └─ 通过Header传递username给project
          ↓ (RestTemplate + Header)
Project服务 (8001)
  ├─ SecurityConfiguration: 允许所有请求
  ├─ UserTransmitFilter: 从Header提取username
  ├─ Controller: 接收请求
  └─ Service: 处理业务逻辑
```

---

## ⚠️ 重要提示

1. **必须重启服务**: 代码修改后，必须重新编译和重启
2. **启动顺序**: 先project，后admin
3. **传递username**: Apifox测试时Headers必须包含username和token
4. **查看日志**: 出问题时第一时间查看控制台日志

---

**修复完成！按照上述步骤重启服务后，应该就能成功测试了 🎉**




