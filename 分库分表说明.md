# 📊 分库分表说明文档

## 🎯 你的分片配置

根据 `project/src/main/resources/shardingsphere-config.yaml`：

### 分片规则
```yaml
actualDataNodes: ds_0.t_link_${0..15}  # 分成16张表
shardingColumn: gid                     # 分片键是gid
type: HASH_MOD                          # 使用哈希取模算法
sharding-count: 16                      # 分片数量16
```

### 数据分布
你的 `t_link` 表被分成了 **16张物理表**：
- `t_link_0`
- `t_link_1`
- `t_link_2`
- ...
- `t_link_15`

### 分片规则
根据 `gid` 字段的哈希值对16取模，决定数据存储在哪张表：
```
hash(gid) % 16 = 表编号
```

例如：
- `gid='15'` → 可能存储在 `t_link_5`
- `gid='abc'` → 可能存储在 `t_link_3`
- 具体由哈希算法决定

---

## 🔍 如何验证分片是否正常工作

### 方法一：查看SQL日志（推荐）

ShardingSphere配置了 `sql-show: true`，会在控制台输出真实执行的SQL。

#### 1. 在IDEA控制台查看project服务的日志

当你调用分页查询时，应该能看到类似这样的日志：

```sql
Logic SQL: SELECT * FROM t_link WHERE gid = ? AND del_flag = 0 LIMIT ?, ?
Actual SQL: ds_0 ::: SELECT * FROM t_link_5 WHERE gid = ? AND del_flag = 0 LIMIT ?, ?
```

**关键信息：**
- `Logic SQL`: 你代码中写的逻辑SQL（查询 t_link 表）
- `Actual SQL`: ShardingSphere实际执行的SQL（查询 t_link_5 表）

#### 2. 观察真实表名

从日志中可以看到 `gid='15'` 的数据被路由到了哪张具体的表。

---

### 方法二：直接查询物理表

在数据库中执行以下SQL，查看数据分布：

```sql
-- 查看每张表的数据量
SELECT 't_link_0' as table_name, COUNT(*) as count FROM t_link_0 WHERE del_flag = 0
UNION ALL
SELECT 't_link_1', COUNT(*) FROM t_link_1 WHERE del_flag = 0
UNION ALL
SELECT 't_link_2', COUNT(*) FROM t_link_2 WHERE del_flag = 0
UNION ALL
SELECT 't_link_3', COUNT(*) FROM t_link_3 WHERE del_flag = 0
UNION ALL
SELECT 't_link_4', COUNT(*) FROM t_link_4 WHERE del_flag = 0
UNION ALL
SELECT 't_link_5', COUNT(*) FROM t_link_5 WHERE del_flag = 0
UNION ALL
SELECT 't_link_6', COUNT(*) FROM t_link_6 WHERE del_flag = 0
UNION ALL
SELECT 't_link_7', COUNT(*) FROM t_link_7 WHERE del_flag = 0
UNION ALL
SELECT 't_link_8', COUNT(*) FROM t_link_8 WHERE del_flag = 0
UNION ALL
SELECT 't_link_9', COUNT(*) FROM t_link_9 WHERE del_flag = 0
UNION ALL
SELECT 't_link_10', COUNT(*) FROM t_link_10 WHERE del_flag = 0
UNION ALL
SELECT 't_link_11', COUNT(*) FROM t_link_11 WHERE del_flag = 0
UNION ALL
SELECT 't_link_12', COUNT(*) FROM t_link_12 WHERE del_flag = 0
UNION ALL
SELECT 't_link_13', COUNT(*) FROM t_link_13 WHERE del_flag = 0
UNION ALL
SELECT 't_link_14', COUNT(*) FROM t_link_14 WHERE del_flag = 0
UNION ALL
SELECT 't_link_15', COUNT(*) FROM t_link_15 WHERE del_flag = 0
ORDER BY count DESC;
```

这样可以看到数据在各个分片表中的分布情况。

---

### 方法三：查找特定gid的数据在哪张表

如果想知道 `gid='15'` 的数据具体在哪张表，可以逐个查询：

```sql
-- 快速查找gid='15'的数据在哪张表
SELECT 't_link_0' as table_name, * FROM t_link_0 WHERE gid = '15' AND del_flag = 0
UNION ALL
SELECT 't_link_1', * FROM t_link_1 WHERE gid = '15' AND del_flag = 0
UNION ALL
SELECT 't_link_2', * FROM t_link_2 WHERE gid = '15' AND del_flag = 0
UNION ALL
SELECT 't_link_3', * FROM t_link_3 WHERE gid = '15' AND del_flag = 0
UNION ALL
SELECT 't_link_4', * FROM t_link_4 WHERE gid = '15' AND del_flag = 0
UNION ALL
SELECT 't_link_5', * FROM t_link_5 WHERE gid = '15' AND del_flag = 0
UNION ALL
SELECT 't_link_6', * FROM t_link_6 WHERE gid = '15' AND del_flag = 0
UNION ALL
SELECT 't_link_7', * FROM t_link_7 WHERE gid = '15' AND del_flag = 0
UNION ALL
SELECT 't_link_8', * FROM t_link_8 WHERE gid = '15' AND del_flag = 0
UNION ALL
SELECT 't_link_9', * FROM t_link_9 WHERE gid = '15' AND del_flag = 0
UNION ALL
SELECT 't_link_10', * FROM t_link_10 WHERE gid = '15' AND del_flag = 0
UNION ALL
SELECT 't_link_11', * FROM t_link_11 WHERE gid = '15' AND del_flag = 0
UNION ALL
SELECT 't_link_12', * FROM t_link_12 WHERE gid = '15' AND del_flag = 0
UNION ALL
SELECT 't_link_13', * FROM t_link_13 WHERE gid = '15' AND del_flag = 0
UNION ALL
SELECT 't_link_14', * FROM t_link_14 WHERE gid = '15' AND del_flag = 0
UNION ALL
SELECT 't_link_15', * FROM t_link_15 WHERE gid = '15' AND del_flag = 0;
```

---

## 💡 为什么能查到数据？

### ShardingSphere的工作原理

```
1. 你的查询：
   SELECT * FROM t_link WHERE gid = '15' LIMIT 0, 10

2. ShardingSphere解析SQL：
   - 识别分片键: gid = '15'
   - 计算路由: hash('15') % 16 = X
   - 确定目标表: t_link_X

3. 改写SQL：
   SELECT * FROM t_link_X WHERE gid = '15' LIMIT 0, 10

4. 执行查询并返回结果
```

### 对应用层透明
- ✅ 你的代码中只需要写 `t_link`
- ✅ ShardingSphere自动路由到正确的物理表
- ✅ 完全不需要关心数据在哪张表

---

## 🎯 分片的优势

### 1. 性能提升
- 单表数据量减少（假设100万数据分16份 = 每表约6万）
- 查询速度更快
- 索引效率更高

### 2. 扩展性强
- 数据量增长时，可以增加分片数量
- 水平扩展能力强

### 3. 高可用
- 可以配置多数据源（主从、读写分离）
- 故障隔离

---

## 📝 注意事项

### 1. 分片键的选择很重要
- 当前使用 `gid` 作为分片键
- 这意味着**同一个gid的数据会在同一张表**
- 查询时必须带上 `gid` 条件，否则会**全表扫描**（扫描16张表）

### 2. 跨分片查询
如果查询不带 `gid`，ShardingSphere会：
```sql
-- 你的查询
SELECT * FROM t_link WHERE click_num > 100

-- 实际执行（广播到所有分片）
SELECT * FROM t_link_0 WHERE click_num > 100
UNION ALL
SELECT * FROM t_link_1 WHERE click_num > 100
UNION ALL
...
SELECT * FROM t_link_15 WHERE click_num > 100
```
性能会下降！

### 3. 分页查询的注意点
当前的分页查询：
```java
ShortLinkPageReqDTO {
    gid: "15",      // ✅ 带了分片键，只查一张表
    current: 1,
    size: 10
}
```
这是最优的查询方式！

---

## 🔍 如何调试分片问题

### 步骤1：开启SQL日志
确认配置中有：
```yaml
props:
  sql-show: true  # ✅ 已开启
```

### 步骤2：查看控制台日志
运行查询时，在project服务的控制台查看：
```
Logic SQL: ...
Actual SQL: ds_0 ::: SELECT * FROM t_link_? ...
```

### 步骤3：验证路由正确性
- 确认实际查询的表名
- 验证是否只查询了1张表（最优）还是多张表（需要优化）

---

## 🎓 测试建议

### 测试1：相同gid的数据在同一张表
```sql
-- 插入多条相同gid的数据
INSERT INTO t_link (...) VALUES (..., gid='15', ...);
INSERT INTO t_link (...) VALUES (..., gid='15', ...);

-- 查询，应该都在同一张表
SELECT * FROM t_link WHERE gid = '15';
```

### 测试2：不同gid的数据分布
```sql
-- 插入不同gid的数据
INSERT INTO t_link (...) VALUES (..., gid='15', ...);
INSERT INTO t_link (...) VALUES (..., gid='abc', ...);
INSERT INTO t_link (...) VALUES (..., gid='xyz', ...);

-- 查看数据分布（可能在不同的表）
```

---

## ✅ 验证清单

确认分片正常工作：

- [ ] 控制台能看到 `Logic SQL` 和 `Actual SQL` 日志
- [ ] 查询时带了 `gid` 参数（避免全表扫描）
- [ ] 能正常查询到数据
- [ ] 数据分布在16张表中（不是都在一张表）
- [ ] 相同gid的数据在同一张表

---

## 🎯 总结

你的分库分表配置是**正确的**，现在能查到数据说明：

1. ✅ ShardingSphere正常工作
2. ✅ 数据已经存储在对应的分片表中
3. ✅ 查询时正确路由到了目标表
4. ✅ admin → project 的远程调用正常

**恭喜你，联调成功！** 🎉

---

## 📚 进阶学习

### 下一步可以学习：
1. 配置多数据源（分库）
2. 读写分离配置
3. 分布式事务处理
4. 数据迁移和扩容
5. 性能优化和监控 